{% extends 'base.html' %}

{% block content %}
<h1>Editor:
  <code><a href="{{url_for('get_folder', vault=vault, subpath=curdir)}}">{{curdir}}</a>/{{curfile.split('/')[-1]}}</code>
</h1>
<link rel="stylesheet" href="{{ url_for('static', filename='editor.css') }}">

<div id="save-status">(saved)</div>

<div class="flo-btn-group">
  <a class="flo-btn" title="Download" id="flo-download-btn"
    href="{{url_for('get_file', vault = vault, subpath = path)}}"><i class="bi bi-download"></i></a>
  <a class="flo-btn" title="View mode" id="flo-toggle-btn"
    href="{{url_for('renderer', vault = vault, subpath = path)}}"><i class="bi bi-eye"></i></a>
  <a class="flo-btn" title="Save" id="flo-save-btn"><i class="bi bi-floppy"></i></a>
</div>

<div id="container">
  <textarea id="editor" class="form-control">{{markdown_text}}</textarea>
  <div id="preview" class="d-none d-lg-block">{{markdown_html|safe}}</div>
</div>





<script>
  const editor = document.getElementById('editor');
  const save_status = document.getElementById('save-status');

  const saveBtn = document.getElementById('flo-save-btn');
  const alertPlaceholder = document.getElementById('page-content-wrapper');

  let saveTimeout = null;
  const SAVE_DELAY = {{ injected_vars["config"].vaults[vault].autosave_time * 1000 }};
  let isDirty = false;

  // функция для показа алерта
  function showAlert(message, type = 'success') {
    const wrapper = document.createElement('div');
    wrapper.innerHTML = `
        <div class="alert alert-${type} alert-dismissible fade show" role="alert">
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>`;
    alertPlaceholder.append(wrapper);

    // autodelete every 5 seconds
    setTimeout(() => {
      const alertNode = bootstrap.Alert.getOrCreateInstance(wrapper.querySelector('.alert'));
      alertNode.close();
    }, 5000);
  }


  function saveDocument() {
    const content = editor.value;
    fetch('{{url_for("save_file", vault=vault, subpath=path)}}', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content })
    })
      .then(res => {
        if (res.ok) {
          isDirty = false;
          save_status.innerText = '(saved)'

          // review update only if the preview is shown
          if (!preview.classList.contains('d-none')) {
            return fetch('{{ url_for("preview", vault=vault, subpath=path) }}')
              .then(res => res.json())
              .then(data => {
                if (data.content !== undefined) {
                  preview.innerHTML = data.content;
                } else {
                  showAlert('Error: server did not return content', 'danger');
                }
              });
          }
        }
      })
      .catch(err => console.error(err));
  }

  // autosave each SAVE_DELAY seconds
  editor.addEventListener('input', () => {
    isDirty = true;
    save_status.innerText = '(unsaved)'
    if (saveTimeout) clearTimeout(saveTimeout);
    saveTimeout = setTimeout(saveDocument, SAVE_DELAY);
  });

  // save button
  saveBtn.addEventListener('click', (e) => {
    e.preventDefault(); // prevent from reloading
    saveDocument();
  });

  // warning when leaving the page
  window.addEventListener('beforeunload', (e) => {
    if (isDirty) {

      e.preventDefault();
      e.returnValue = '';
    }
  });
</script>

{% endblock %}